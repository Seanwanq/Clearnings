# 面向对象编程

## 章节目录

* 面向对象编程
* 类和对象
* 类的成员变量
* 访问修饰符
* 构造与解析函数
* this 指针

## 什么是面向对象

### 定义

所谓面向对象就是基于对象概念，以对象为中心，以类和继承为构造机制，来认识、理解、刻画客观世界和设计、构建相应的软件系统（模拟现实）

1. 对象是由数据和容许的操作组成的封装体， 与客观实体有直接对应关系
2. 面向对象不是某一种语言的特性，而是一种编程思想
3. 对象的组成：属性、行为
4. 与传统编程（过程阶段决策）不同的是在运行阶段进行决策

## 抽象和类

### 抽象

* 从具体事务抽取共同的本质特征

### C++中的类

* 类是一种将抽象转换为用户定义类型的工具
* 将数据表示和操纵数据的方法组合成一个整体
* 类的实例成为对象
* 类中的变量和函数称为成员

## 类的声明和使用

### 类的声明

* 使用class / struct关键字声明类型

`class 类名{};`
`class LandOwner{};`
\
`struct 类名{};`
`struct Hero{};`

> 注意：
>
> 1. class方式声明的类型与struct声明的类型仅仅是形式上的不同
>
> 2. 其唯一的区别在于使用class声明的类型默认成员是私有的(private)，而struct声明的类型默认是公有的(public)


> POD <- 老式数据

## 访问修饰符

### 常见访问修饰符

* public: 修饰的成员在任意地方都可以访问
* private: 修饰的成员只能在类中或者友元函数中可以访问
* protected: 修饰的成员可以在类中函数、子函数及友元函数中访问

### 修饰成员

* 将修饰关键字放置在类定义的大括号中，添加冒号

```cpp
class 类名{
    修饰符:
        成员列表;
};
```

```cpp
class LandOwner{
    private:
        string name;
    public:
        void PlayCard();
}
```

## 类的成员函数

### 函数声明

```c++
class 类名{
    修饰符1:
        变量1类型 变量1名称;
        变量2类型 变量2名称;
    修饰符2:
        函数1返回类型 函数1名称();
}；
```

```c++
class LandOwner{
    public:
        string name;
        long score;
    private:
        void ShowScore();
};
```

## 函数定义

```c++
返回类型 类名::函数名(){
    //函数操作
}
```

```c++
void LandOwner::ShowScore(){        // :: <- 作用域解析运算符
    cout << score << endl;
}
```

## 构造函数

### 构造函数

* 以类名作为函数名
* 无返回值类型
* 构造函数是给编译器看的

### 作用

* 初始化对象的数据成员
* 类对象被创建时，编译器为对象分配内存空间并自动调用构造函数以完成成员的初始化

### 构造函数的种类

* 无参构造
* 一般构造(重载构造)
* 拷贝构造

```c++
class LandOwner{
    private:
        int userld;
    public:
        LandOwner()
        {
            userld = 10000;
        }
}
```

## 带参构造

```c++
类名::构造(类型1 参数1, 类型2 参数2, ...){
    //相关初始化代码
}
```

```c++
Student::Student(string name, string desc){
    _name = name;
    _desc = desc;
}
```

```c++
Student *stu = new Student("撒贝宁", "北大还行");
stu->ShowInfo();
```



## 栈内存与堆内存

## 析构函数

* 对象过期时自动调用的特殊成员函数
* 析构函数一般用来完成清理工作
* 析构函数的名称实在类名前加上~
  * 析构函数没有参数，只能有一个

```c++
class Student{
    private:
        double *scores;
    public:
        Student(int len)
        {
            //使用new分配资源
            scores = new double[len];
        }
        ~Student()
        {
            delete scores;      //释放资源
        }
}
```

### 注意：

1. 析构函数用来释放对象使用的资源，并销毁对象的非static数据成员
2. 无论何时一个对象被销毁，都会自动调用其析构函数（隐式函数）


## 使用类创建对象

### 第一种实例化方式

* 栈内存中创建：类似声明变量

`自定义类型名 对象名[([参数列表])];`
\
`Student stu();`
`Student stu;`

注意：

1. stu对象由系统创建并释放，不用担心会出现内存泄漏
2. 生命周期只在声明区域的大括号内
3. 栈内存的优势是存取速度比较快(仅次于)寄存器),缺点是存在栈中的数据大小与生存期必须是确定的,缺乏灵活性

> 适合做一点简单的操作

### 第二种实例化方式

* 在堆内存中创建: 需要new关键字

```c++
Student * p_stu1 = new Student();
Student * p_stu2 = new Student;
auto * p_stu3 = new Student();      //变量的自动类型推断
//auto并不是严格意义上的变量，只能通过后面来推断
//c++11之后才可以使用auto
//若代码量巨大不建议使用auto，因为会占用大量系统资源
```

注意：

1. p_stu1是指针，必须使用delete释放
2. 使用灵活（可以赋值给全局变量，可以把对象作为函数的返回值返回）
3. 用好了功能强大，用不好很危险


